{
  "language": "Solidity",
  "sources": {
    "contracts/FundMe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// 1. Pragma\npragma solidity ^0.8.0;\n\n// 2. Imports\nimport \"./PriceConverter.sol\";\n\n// 3. Error Codes\n// A different way to throw errors -> more gas efficient\nerror FundMe__NotOwner();\n\n// 4. Libraries\n// 5. Interfaces\n\n// 6. Contracts\ncontract FundMe {\n    // 6.1. Type Declarations\n    // Using a PriceConverter library to extract the math operations from the contract\n    using PriceConverter for uint256;\n\n    // 6.2. State Variables\n    mapping(address => uint256) public addressToAmountFunded;\n    address[] public funders;\n\n    // \"immutable\" keyword only allows to update variable once after\n    // declaring them (perfect for constructors + saves gas)\n    address public immutable i_owner;\n\n    // \"constant\" keyword prevents variable from being updated + saves gas\n    uint256 public constant MINIMUM_USD = 50 * 1e18;\n    AggregatorV3Interface public priceFeed; // \"priceFeed\" *CONTRACT*\n\n    // 6.3. Events (none here)\n\n    // 6.4. Modifiers\n    modifier onlyOwner() {\n        // 0. Ensuring only the address that deployed this contract can withdraw funds\n        // Run this code first\n\n        // Few ways to do this:\n        // 1. Old school\n        // require(msg.sender == i_owner, \"Sender is not the owner!\");\n\n        // 2. New & more gas efficient\n        if (msg.sender != i_owner) {\n            revert FundMe__NotOwner();\n        }\n        // Run the rest of the func\n        _;\n    }\n\n    // 6.5. Functions\n    // 6.5.1 Constructors\n    constructor(address priceFeedAddress) {\n        // Assigning the owner in the constructor because it only runs once the contract is deployed\n        // (aka we already have access to \"msg.sender\" address)\n        i_owner = msg.sender;\n\n        // Making our \"priceFeedAddress\" dynamic (so it could be used with different addresses)\n        // ** By matching ABI (\"AggregatorV3Interface\") with the contract address (\"priceFeedAddress\"),\n        // ** we get access to the *interface* itself & then are able to interact with it (e.g. get price, etc.)\n        priceFeed = AggregatorV3Interface(priceFeedAddress);\n    }\n\n    // 6.5.2. Receive\n    // Triggering \"fund()\" func if someone sends ETH to this contract\n    // without the \"fund()\" func\n    receive() external payable {\n        fund();\n    }\n\n    // 6.5.3. Fallback\n    fallback() external payable {\n        fund();\n    }\n\n    // 6.5.4. External Funcs\n\n    // 6.5.5. Public Funcs\n    function fund() public payable {\n        // \"1e18\" = 1 * 10^18\n        // Library functions automatically use the values they're used as\n        // methods for as their initial argument\n        // e.g. \"msg.value\" is used as the first argument for \"getConversionRate(uint256 ethAmount)\"\n        // Additional arguments should be added normally e.g. for \"getConversionRate (uint256 ethAmount, uint256 smthElse)\"\n        // We'd use \"msg.value.getConversionRate(123)\", \"123\" being \"smthElse\"\n        require(\n            msg.value.getConversionRate(priceFeed) >= MINIMUM_USD,\n            \"Not enough eth sent!\"\n        );\n        addressToAmountFunded[msg.sender] += msg.value;\n        funders.push(msg.sender);\n    }\n\n    function withdraw() public onlyOwner {\n        // 1. Resetting the amounts funded by each funder to 0\n        for (\n            uint256 funderIndex = 0;\n            funderIndex < funders.length;\n            funderIndex++\n        ) {\n            address funder = funders[funderIndex];\n            addressToAmountFunded[funder] = 0;\n        }\n\n        // 2. Resetting the array\n        funders = new address[](0);\n\n        // 3. Withdraw the funds (to the caller of this contract)\n\n        // ** 3 ways to send funds in EVM: **\n        // 1) Transfer\n        // \"msg.sender\" -> address data type | \"payable(msg.sender)\" -> address payable data type\n        // Funds go from msg.sender to the caller of this contract? NO\n        // Funds go from \"address(this)\" to \"msg.sender\" (who, in this case,\n        // I guess is the caller of this contract?)\n        // payable(msg.sender).transfer(address(this).balance);\n\n        // 2) Send\n        // bool sendSuccess = payable(msg.sender).send(address(this).balance);\n        // require(sendSuccess, \"Send failed\");\n\n        // 3) Call - *currently the recommended way to send & receive funds*\n        // leaving \"call()\" blank since we don't want to call this func on any other contract\n        (bool callSuccess, ) = payable(msg.sender).call{\n            value: address(this).balance\n        }(\"\");\n        require(callSuccess, \"Call failed\");\n    }\n\n    // 6.5.6. Internal Funcs (none here)\n    // 6.5.7. Private Funcs (none here)\n    // 6.5.8. View/Pure Funcs (none here)\n}\n"
    },
    "contracts/PriceConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// Importing an interface (& most importantly, its ABI) to interact with it\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nlibrary PriceConverter {\n    // Getting price of ETH in USD\n    // ** Libraries only get embedded into the contract if the library functions are *internal*\n    function getPrice(AggregatorV3Interface priceFeed)\n        internal\n        view\n        returns (uint256)\n    {\n        // AggregatorV3Interface priceFeed = AggregatorV3Interface(\n        //     0xD4a33860578De61DBAbDc8BFdb98FD742fA7028e\n        // );\n        (, int256 price, , , ) = priceFeed.latestRoundData();\n\n        // To get the ETH price in USD, we should divide \"price\" by 1e8\n        // (since now it is e.g. 160000000000 but should be 1,600.00000000 USD))\n        // \"msg.value\", however should be divided by 1e18 to get the price in ETH\n        // since it's currently expressed in wei (x ETH * 1e18)\n        // Hence, we're multiplying \"price\" by 1e10 to match \"msg.value\" format\n\n        // Also changing price data type from \"int256\" to \"uint256\" -> not sure why\n        return uint256(price * 1e10);\n    }\n\n    // ** Libraries only get embedded into the contract if the library functions are *internal*\n    function getConversionRate(\n        uint256 ethAmount,\n        AggregatorV3Interface priceFeed\n    ) internal view returns (uint256) {\n        uint256 ethPrice = getPrice(priceFeed);\n\n        // If we multiplied \"ethPrice\" & \"ethAmount\" without dividing it by 1e18,\n        // we would've received 36 0's in the result.\n        uint256 ethAmountInUsd = (ethPrice * ethAmount) / 1e18;\n        return ethAmountInUsd;\n    }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}